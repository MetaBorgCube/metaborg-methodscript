module analysis/MethodScript

imports
	signatures/-
	analysis/Types

signature
	name resolution
		namespaces Var IVar Proc
	
	functions
		binOpNumberType : (Type * Type) -> Type {
			(Int()   , Int())    -> Int(),
			(Double(), _)        -> Double(),
			(_       , Double()) -> Double(),
			(_       , _)        -> Number()
		}

rules
	
	// Scope initialization.
	init ^ (scope_global) :=
		new scope_global,
		
		// Define type relations.
		// Child  <! Parent: "Child can be used as Parent".
		Any()     <! Boolean(),
		Any()     <! Int(),
		Any()     <! Double(),
		Any()     <! String(),
		Any()     <! Array(),
		Any()     <! Slice(),
		Any()     <! Closure(),
		Any()     <! Null(),
		Any()     <! Void(),
		Any()     <! ClassType(),
		
		Null()    <! Boolean(),
		Null()    <! Int(),
		Null()    <! Double(),
		Null()    <! String(),
		Null()    <! Array(),
		Null()    <! Slice(),
		Null()    <! Closure(),
		Null()    <! ClassType(),
		
		Int()     <! Number(),
		Double()  <! Number(),
		
		Slice()   <! Array().
	
	// MethodScript program.
	[[ Empty() ^ (scope_global) ]].
	[[ Ms(statements) ^ (scope_global) ]] :=
		
		// Create file scope.
		new scope_file,
		
		// Disallow duplicate procedure declarations.
		distinct/name W(scope_global)/Proc | error $[Duplicate procedure declaration: [NAME]] @NAMES,
		
		Map1T[[ statements ^ (scope_file, scope_global) : _ ]].
	
	[[ Msa(cmds) ^ (scope_global) ]] :=
		new scope_file,
		Map1[[ cmds ^ (scope_file, scope_global) ]].
	
	// Variable references.
	[[ IVar(varName) ^ (s, scope_global) : t ]] :=
		IVar{varName} -> s, // varName is a reference in s.
		IVar{varName} |-> d | error $[Cannot find variable: [varName]],
		d : t.
	[[ Var(varName) ^ (s, scope_global) : t ]] :=
		Var{varName} -> s, // varName is a reference in s.
		Var{varName} |-> d | error $[Cannot find variable: [varName]],
		d : t.
	
	// IVariable parameters.
	// With 1 scope, the param is declared and resolved in the same scope.
	// With 2 scopes, the param is declared in the second scope and its value resolved in the first.
	[[ IVarParam(cType, varName) ^ (s, scope_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName@s} <- s,
		IVar{varName@s} : varType,
		varType == Any().
	[[ IVarAssignParam(cType, varName, valExp) ^ (s, scope_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName@s} <- s,
		IVar{varName@s} : varType,
		[[ valExp ^ (s, scope_global) : valType ]],
		varType == Any(), // TODO - Change to valType when every assign will have its own scope.
		valType <? varType.
	[[ IVarScopeParam(cType, varName) ^ (scope_parent, scope_params, scope_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName} <- scope_params,
		IVar{varName} : varType,
		varType == Any().
	[[ IVarAssignScopeParam(cType, varName, valExp) ^ (scope_parent, scope_params, scope_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName} <- scope_params,
		IVar{varName} : varType,
		[[ valExp ^ (scope_parent, scope_global) : valType ]],
		varType == Any(),
		valType <? varType.
	
	// Static values.
	[[ IntVal(_) ^ (s, scope_global) : Int() ]].
	[[ DoubleVal(_) ^ (s, scope_global) : Double() ]].
	[[ StringVal(_) ^ (s, scope_global) : String() ]].
	[[ SmartStringVal(_) ^ (s, scope_global) : String() ]].
	[[ ClassTypeVal(_) ^ (s, scope_global) : ClassType() ]].
	[[ True() ^ (s, scope_global) : Boolean() ]].
	[[ False() ^ (s, scope_global) : Boolean() ]].
	[[ Null() ^ (s, scope_global) : Null() ]].
	
	// Command declarations.
	[[ CmdDecl(cmdName, args, optArgs, body) ^ (s, scope_global) ]] :=
		new scope_cmd,
		Map1[[ args ^ (scope_cmd, scope_global) ]],
		Map1[[ optArgs ^ (scope_cmd, scope_global) ]],
		[[ body ^ (scope_cmd, scope_global) ]],
		distinct/name W(scope_cmd)/Var | error $[Duplicate variable declaration: [NAME]] @NAMES.
	
	[[ CmdArgDecl(varName) ^ (s, scope_global) ]] :=
		Var{varName} <- s,
		Var{varName} : String(). // All $variables are strings.
	
	[[ SingleLine(statement) ^ (s, scope_global) ]] :=
		[[ statement ^ (s, scope_global) : _ ]].
	[[ MultiLine(statements) ^ (s, scope_global) ]] :=
		Map1T[[ statements ^ (s, scope_global) : _ ]].
	
	// Unary and binary expressions.
	[[ UnExp(_, e) ^ (s, scope_global) : Any() ]] :=
		[[ e ^ (s, scope_global) : t1 ]].
	[[ BinExp(Add(), e1, e2) ^ (s, scope_global) : t ]] := // TODO - Determine how to implement + move Math section?
		[[ e1 ^ (s, scope_global) : t1 ]],
		[[ e2 ^ (s, scope_global) : t2 ]],
//		t1 <? Number(),
//		t2 <? Number(),
		t is binOpNumberType of (t1, t2). // TODO - Apply to all BinOps that take numbers like this.
	[[ BinExp(_, e1, e2) ^ (s, scope_global) : Any() ]] :=
		[[ e1 ^ (s, scope_global) : t1 ]],
		[[ e2 ^ (s, scope_global) : t2 ]].
	
	// Generic optional node arguments.
	[[ None() ^ (s, scope_global) : _ ]] :=
		true.
	
	// Statement brackets.
	[[ Block(statements) ^ (s, scope_global) : _ ]] :=
		Map1T[[ statements ^ (s, scope_global) : _ ]].
	
	// Function calls.
	// TODO - Check against API to see whether a function exists?
	// TODO - Obtain type info from the API somehow?
	[[ FuncCall(funcName, argExps) ^ (s, scope_global) : Any() ]] :=
		Map1T[[ argExps ^ (s, scope_global) : argTypes ]].
	
	// ArrayHandling nodes.
	[[ ArrayPush(arrayExp, valExp) ^ (s, scope_global) : Void() ]] :=
		[[ arrayExp ^ (s, scope_global) : arrayType ]],
		[[ valExp ^ (s, scope_global) : _ ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	[[ ArrayClone(arrayExp) ^ (s, scope_global) : Array() ]] :=
		[[ arrayExp ^ (s, scope_global) : arrayType ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	[[ ArrayGet(arrayExp, indExp) ^ (s, scope_global) : Any() ]] :=
		[[ arrayExp ^ (s, scope_global) : arrayType ]],
		[[ indExp ^ (s, scope_global) : _ ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	[[ SliceStatic(val1, val2) ^ (s, scope_global) : Slice() ]] :=
		true.
	
	[[ SliceDynamic(exp1, exp2) ^ (s, scope_global) : Slice() ]] :=
		[[ exp1 ^ (s, scope_global) : t1 ]],
		[[ exp2 ^ (s, scope_global) : t2 ]],
		t1 <? Int(),
		t2 <? Int().
	
	[[ ArraySet(arrayExp, indExp, valExp) ^ (s, scope_global) : valType ]] :=
		[[ arrayExp ^ (s, scope_global) : arrayType ]],
		[[ indExp ^ (s, scope_global) : t1 ]], // TODO - Only allow int or string here?
		[[ valExp ^ (s, scope_global) : valType ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	// BasicLogic nodes.
	// None (handled through UnOp and BinOp).
	
	// ControlFlow nodes.
	[[ IfElse(ifBlocks, elseCode) ^ (s, scope_global) : Void() ]] :=
		Map1T[[ ifBlocks ^ (s, scope_global) : _ ]],
		Map1T[[ elseCode ^ (s, scope_global) : _ ]].
	[[ IfElseIfBlock(cond, code) ^ (s, scope_global) : codeType ]] :=
		[[ cond ^ (s, scope_global) : condType ]],
		Map1T[[ code ^ (s, scope_global) : codeType ]],
		condType <? Boolean().
	
	[[ While(cond, code) ^ (s, scope_global) : Void() ]] :=
		[[ cond ^ (s, scope_global) : condType ]],
		Map1T[[ code ^ (s, scope_global) : _ ]],
		condType <? Boolean().
	
	[[ DoWhile(code, cond) ^ (s, scope_global) : Void() ]] :=
		Map1T[[ code ^ (s, scope_global) : _ ]],
		[[ cond ^ (s, scope_global) : condType ]],
		condType <? Boolean().
	
	[[ For(assign, cond, exp, code, None()) ^ (s, scope_global) : Void() ]] :=
		[[ assign ^ (s, scope_global) : _ ]],
		[[ cond ^ (s, scope_global) : condType ]],
		[[ exp ^ (s, scope_global) : _ ]],
		Map1T[[ code ^ (s, scope_global) : _ ]],
		condType <? Boolean().
	[[ For(assign, cond, exp, code, elseCode) ^ (s, scope_global) : Void() ]] :=
		[[ assign ^ (s, scope_global) : _ ]],
		[[ cond ^ (s, scope_global) : condType ]],
		[[ exp ^ (s, scope_global) : _ ]],
		Map1T[[ code ^ (s, scope_global) : _ ]],
		Map1T[[ elseCode ^ (s, scope_global) : _ ]],
		condType <? Boolean().
	
	[[ ForEach(key, val, arrayExp, code, None()) ^ (s, scope_global) : Void() ]] :=
		[[ key ^ (s, scope_global) : _ ]],
		[[ val ^ (s, scope_global) : _ ]],
		[[ arrayExp ^ (s, scope_global) : arrayType ]],
		Map1T[[ code ^ (s, scope_global) : _ ]],
		arrayType <? Array().
	[[ ForEach(key, val, arrayExp, code, elseCode) ^ (s, scope_global) : Void() ]] :=
		[[ key ^ (s, scope_global) : _ ]],
		[[ val ^ (s, scope_global) : _ ]],
		[[ arrayExp ^ (s, scope_global) : arrayType ]],
		Map1T[[ code ^ (s, scope_global) : _ ]],
		Map1T[[ elseCode ^ (s, scope_global) : _ ]],
		arrayType <? Array().
	
	[[ Switch(exp, cases, defaultCode) ^ (s, scope_global) : Void() ]] :=
		[[ exp ^ (s, scope_global) : _ ]],
		Map1[[ cases ^ (s, scope_global) ]],
		Map1T[[ defaultCode ^ (s, scope_global) : _ ]].
	[[ SwitchCase(vals, code) ^ (s, scope_global) ]] :=
		Map1T[[ vals ^ (s, scope_global) : _ ]],
		Map1T[[ code ^ (s, scope_global) : _ ]].
	
	[[ SwitchExp(exp, cases, defaultExp) ^ (s, scope_global) : returnType ]] :=
		[[ exp ^ (s, scope_global) : _ ]],
		// TODO - Set returnType based on caseExpTypes and defaultType.
		Map1T[[ cases ^ (s, scope_global) : caseExpTypes ]],
		[[ defaultExp ^ (s, scope_global) : defaultType ]],
		returnType == Any().
	[[ SwitchExpCase(vals, exp) ^ (s, scope_global) : t ]] :=
		Map1T[[ vals ^ (s, scope_global) : _ ]],
		[[ exp ^ (s, scope_global) : t ]].
	
	[[ Break(None()) ^ (s, scope_global) : Void() ]] :=
		// TODO - Only allow in loops.
		true.
	[[ Break(Some(numLoops)) ^ (s, scope_global) : Void() ]] :=
		// TODO - Only allow in loops. How to deal with numLoops?
		[[ numLoops ^ (s, scope_global) : numLoopsType ]],
		numLoopsType <? Int().
	[[ Continue(None()) ^ (s, scope_global) : Void() ]] :=
		// TODO - Only allow in specific loops.
		true.
	[[ Continue(Some(numLoopsSkipped)) ^ (s, scope_global) : Void() ]] :=
		// TODO - Only allow in specific loops.
		[[ numLoopsSkipped ^ (s, scope_global) : numLoopsSkippedType ]],
		numLoopsSkippedType <? Int().
	[[ Return(Some(exp)) ^ (s, scope_global) : Void() ]] :=
		// TODO - Only allow in procedures and closures.
		[[ exp ^ (s, scope_global) : _ ]]. // TODO - Use this to determine procedure return types?
	[[ Return(None()) ^ (s, scope_global) : Void() ]] :=
		// TODO - Only allow in procedures and closures.
		true.
	[[ Die(Some(exp)) ^ (s, scope_global) : Void() ]] :=
		[[ exp ^ (s, scope_global) : expType ]],
		expType <? String().
	[[ Die(None()) ^ (s, scope_global) : Void() ]] :=
		true.
	
	[[ Ternary(cond, ifExp, elseExp) ^ (s, scope_global) : returnType ]] :=
		// TODO - Return hybrid type if possible?
		[[ cond ^ (s, scope_global) : condType ]],
		[[ ifExp ^ (s, scope_global) : t1 ]],
		[[ elseExp ^ (s, scope_global) : t2 ]],
		returnType == Any(),
		condType <? Boolean().
	
	[[ ProcCall(procName, argExps) ^ (s, scope_global) : Any() ]] :=
		// TODO - Do argument length check. Warn about mismatching arg size?
		// The MS compiler simply ignores too many arguments and assigns null to undefined args.
		// TODO - Get return type from return statements.
		Proc{procName} -> scope_global,
		Proc{procName} |-> d | error $[Cannot find procedure: [procName]],
		Map1T[[ argExps ^ (s, scope_global) : argTypes ]].
	
	[[ ProcCallDynamic(procNameExp, argExps) ^ (s, scope_global) : returnType ]] :=
		[[ procNameExp ^ (s, scope_global) : procNameType ]],
		Map1T[[ argExps ^ (s, scope_global) : argTypes ]],
		returnType == Any(),
		procNameType <? String().
	
	[[ ProcCallDynamicArray(procNameExp, argsArray) ^ (s, scope_global) : returnType ]] :=
		[[ procNameExp ^ (s, scope_global) : procNameType ]],
		[[ argsArray ^ (s, scope_global) : Array() ]],
		returnType == Any(),
		procNameType <? String().
	
	// DataHandling nodes.
	[[ ProcDecl(procName, params, code) ^ (s, scope_global) : Void() ]] :=
		
		// Store proc declaration in global scope.
		Proc{procName} <- scope_global,
		// TODO - Store proc metadata (param types, return type).
		
		// Add scope_params as child of the parent scope.
		new scope_params,
		scope_params ---> s,
		
		// Add scope_proc as child of the params scope.
		new scope_proc,
		scope_proc ---> scope_params,
		
		// Add parameters to params scope.
		Map1T[[ params ^ (s, scope_params, scope_global) : _ ]],
		
		// Resolve code in proc scope.
		Map1T[[ code ^ (scope_proc, scope_global) : _ ]].
	
	[[ Array(entries) ^ (s, scope_global) : Array()]] :=
		Map1T[[entries ^ (s, scope_global) : _ ]]. // TODO - Check for duplicate keys?
	[[ AssocArray(entries) ^ (s, scope_global) : Array() ]] :=
		Map1T[[entries ^ (s, scope_global) : _ ]]. // TODO - Check for duplicate keys?
	[[ ArrayLabelEntry(_, valExp) ^ (s, scope_global): _ ]] :=
		[[ valExp ^ (s, scope_global) : _ ]].
	
	// TODO - Check whether casts are possible on the given types?
	[[ BoolCast(exp) ^ (s, scope_global) : Boolean() ]] :=
		[[ exp ^ (s, scope_global) : t ]].
	[[ DoubleCast(exp) ^ (s, scope_global) : Double() ]] :=
		[[ exp ^ (s, scope_global) : t ]].
	[[ IntCast(exp) ^ (s, scope_global) : Int() ]] :=
		[[ exp ^ (s, scope_global) : t ]].
	[[ StringCast(exp) ^ (s, scope_global) : String() ]] :=
		[[ exp ^ (s, scope_global) : t ]].
	
	[[ Closure(params, code) ^ (s, scope_global) : Closure() ]] :=
		// TODO - Store metadata (param types, return type).
		
		// Add scope_params as child of the parent scope.
		new scope_params,
		scope_params ---> s,
		
		// Add scope_closure as child of the params scope.
		new scope_closure,
		scope_closure ---> scope_params,
		
		// Add parameters to params scope.
		IVar{"@arguments"} <- scope_params, // Automatically added.
		IVar{"@arguments"} : Array(),
		Map1T[[ params ^ (s, scope_params, scope_global) : _ ]],
		
		// Resolve code in closure scope.
		Map1T[[ code ^ (scope_closure, scope_global) : _ ]].
	
	[[ IClosure(params, code) ^ (s, scope_global) : Closure() ]] :=
		// TODO - Store metadata (param types, return type).
		
		// Create scope_params.
		new scope_params,
		
		// Add scope_closure as child of the params scope.
		new scope_closure,
		scope_closure ---> scope_params,
		
		// Add parameters to params scope.
		IVar{"@arguments"} <- scope_params, // Automatically added.
		IVar{"@arguments"} : Array(),
		Map1T[[ params ^ (s, scope_params, scope_global) : _ ]],
		
		// Resolve code in closure scope.
		Map1T[[ code ^ (scope_closure, scope_global) : _ ]].
	
	[[ RClosure(params, code) ^ (s, scope_global) : Closure() ]] :=
		// TODO - Store metadata (param types, return type).
		
		// Create scope_params.
		new scope_params,
		
		// Add scope_closure as child of the params scope.
		new scope_closure,
		scope_closure ---> scope_params,
		
		// Add parameters to params scope.
		IVar{"@arguments"} <- scope_params, // Automatically added.
		IVar{"@arguments"} : Array(),
		Map1T[[ params ^ (s, scope_params, scope_global) : _ ]],
		
		// Resolve code in closure scope.
		Map1T[[ code ^ (scope_closure, scope_global) : _ ]].
	
	[[ IVarAssign(cType, IVar(varName), valExp) ^ (s, scope_global) : Any() ]] :=
		// TODO - Start new scope for every assign and remove "@s".
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName@s} <- s,
		IVar{varName@s} : Any(),
		[[ valExp ^ (s, scope_global) : valType ]].
//		valType <? varType. // TODO - Return valType when every assign has a new scope?
	[[ IVarAssign(cType, varExp, valExp) ^ (s, scope_global) : Any() ]] :=
		// TODO - Merge with other IVarAssign if possible?
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		[[ varExp ^ (s, scope_global) : _ ]],
		[[ valExp ^ (s, scope_global) : _ ]],
		varExp == ArrayGet(_, _).
	
	// EventBinding nodes.
	// TODO - Allow only in event context (within a Bind()).
	[[ Cancel(None()) ^ (s, scope_global) : Void() ]] :=
		true.
	[[ Cancel(exp) ^ (s, scope_global) : Void() ]] :=
		[[ exp ^ (s, scope_global) : Boolean() ]].
	
	[[ Consume() ^ (s, scope_global) : Void() ]] :=
		true.
	
	[[ Lock(exps) ^ (s, scope_global) : Void() ]] :=
		// TODO - Check types.
		Map1T[[ exps ^ (s, scope_global) : types ]].
	
	[[ IsCancelled() ^ (s, scope_global) : Boolean() ]] :=
		true.
	
	[[ IsConsumed() ^ (s, scope_global) : Boolean() ]] :=
		true.
	
	[[ IsLocked(exp) ^ (s, scope_global) : Boolean() ]] :=
		[[ exp ^ (s, scope_global) : String() ]].
	
	[[ Bind(name, prio, filter, eventVarName, params, code) ^ (s, scope_global) : String() ]] :=
		[[ name ^ (s, scope_global) : nameType ]],
		nameType <? String(),
		[[ prio ^ (s, scope_global) : prioType ]],
		prioType <? Array(),
		[[ filter ^ (s, scope_global) : filterType ]],
		filterType <? Array(),
		
		// Create scope_params.
		new scope_params,
		
		// Add scope_bind as child of the params scope.
		new scope_bind,
		scope_bind ---> scope_params,
		
		// Add event variable and parameters to params scope.
		IVar{eventVarName} <- scope_params,
		IVar{eventVarName} : Array(),
		Map1T[[ params ^ (s, scope_params, scope_global) : _ ]],
		
		// Resolve code in bind scope.
		Map1T[[ code ^ (scope_bind, scope_global) : _ ]].
	
	[[ ModifyEvent(paramExp, valExp, Some(throwOnFailExp)) ^ (s, scope_global) : Boolean() ]] :=
		[[ paramExp ^ (s, scope_global) : paramType ]],
		paramType <? String(),
		[[ valExp ^ (s, scope_global) : _ ]],
		[[ throwOnFailExp ^ (s, scope_global) : throwOnFailType ]],
		throwOnFailType <? Boolean().
	[[ ModifyEvent(paramExp, valExp, None()) ^ (s, scope_global) : Boolean() ]] :=
		[[ paramExp ^ (s, scope_global) : paramType ]],
		paramType <? String(),
		[[ valExp ^ (s, scope_global) : _ ]].
	
	// Exceptions nodes.
	[[ TryLegacy(code, None()) ^ (s, scope_global) : Void() ]] :=
		Map1T[[ code ^ (s, scope_global) : _ ]].
	[[ TryLegacy(code, Some(catchBlock)) ^ (s, scope_global) : Void() ]] :=
		Map1T[[ code ^ (s, scope_global) : _ ]],
		[[ catchBlock ^ (s, scope_global) : _ ]].
	[[ CatchCodeLegacy(code) ^ (s, scope_global) : _ ]] :=
		Map1T[[ code ^ (s, scope_global) : _ ]].
	[[ CatchBlockLegacy(param, code, None()) ^ (s, scope_global) : _ ]] :=
		[[ param ^ (s, scope_global) : _ ]],
		Map1T[[ code ^ (s, scope_global) : _ ]].
	[[ CatchBlockLegacy(param, code, Some(exceptions)) ^ (s, scope_global) : _ ]] :=
		[[ param ^ (s, scope_global) : _ ]],
		Map1T[[ code ^ (s, scope_global) : _ ]],
		[[ exceptions ^ (s, scope_global) : exArrayType ]],
		exArraySize <? Array().
	
	[[ CTry(code, catchBlocks, None()) ^ (s, scope_global) : Void() ]] :=
		Map1T[[ code ^ (s, scope_global) : _ ]],
		Map1T[[ catchBlocks ^ (s, scope_global) : _ ]].
	[[ CTry(code, catchBlocks, Some(finallyCode)) ^ (s, scope_global) : Void() ]] :=
		Map1T[[ code ^ (s, scope_global) : _ ]],
		Map1T[[ catchBlocks ^ (s, scope_global) : _ ]],
		Map1T[[ finallyCode ^ (s, scope_global) : _ ]].
	[[ CTryCatchBlock(param, code) ^ (s, scope_global) : _ ]] :=
		[[ param ^ (s, scope_global) : _ ]],
		Map1T[[ code ^ (s, scope_global) : _ ]].
	
	[[ GetStackTrace() ^ (s, scope_global) : Array() ]] :=
		true.
	
	// Math nodes.
	// None (handled through UnOp and BinOp).
	
	// StringHandling nodes.
	// None (handled through BinOp).

module analysis/MethodScript

imports
	signatures/-
	analysis/Types

signature
	name resolution
		labels
			P // Default scope edge label (s1 -P-> s2 === s1 ---> s2).
			I // Default scope association label (occ ===> s === occ =I=> s).
			LP // Low priority scope edge label.
		
		order
			D < P,
			D < I,
			I < P,
			D < LP,
			I < LP,
			P < LP
		
		well-formedness
			P* I* LP*
	
	namespaces Var IVar TypedIVar Proc ClassType
	
	functions
		binOpNumberType : (Type * Type) -> Type {
			(Int()   , Int())    -> Int(),
			(Double(), _)        -> Double(),
			(_       , Double()) -> Double(),
			(_       , _)        -> Number()
		}
	
	constructors
		ClassType : TYPE -> ClassType

rules
	
	// Double Scope Mapping rule with two additional scopes that will directly be passed on.
	// The first two scopes are linked such that s1 <- s1' <- s2 <- s2'.
	DSMap1T[[ [x|xs] ^ (s, s', s_extra, s_global) : [ty|tys] ]] :=
		new s2,
		new s2',
		s2 -P-> s',
		s2' -P-> s2,
		[[ x ^ (s2, s2', s_extra, s_global) : ty ]],
		DSMap1T[[ xs ^ (s2, s2', s_extra, s_global) : tys ]].
	
	// Scope initialization.
	init ^ (s_global) :=
		new s_global,
		
		// Define type relations.
		// Child  <! Parent: "Child can be used as Parent".
		Any()     <! Boolean(),
		Any()     <! Int(),
		Any()     <! Double(),
		Any()     <! String(),
		Any()     <! Array(),
		Any()     <! Slice(),
		Any()     <! Closure(),
		Any()     <! Null(),
		Any()     <! Void(),
		Any()     <! ClassType(),
		Any()     <! ArrayAccess(),
		Any()     <! Mixed(),
		
		Boolean() <! Mixed(),
		Int()     <! Mixed(),
		Double()  <! Mixed(),
		String()  <! Mixed(),
		Array()   <! Mixed(),
		Slice()   <! Mixed(),
		Closure() <! Mixed(),
		Null()    <! Mixed(),
		Void()    <! Mixed(),
		ClassType() <! Mixed(),
		ArrayAccess() <! Mixed(),
		
		Null()    <! Boolean(),
		Null()    <! Int(),
		Null()    <! Double(),
		Null()    <! String(),
		Null()    <! Array(),
		Null()    <! Slice(),
		Null()    <! Closure(),
		Null()    <! ClassType(),
		Null()    <! Mixed(),
		
		Int()     <! Number(),
		Double()  <! Number(),
		
		Array()   <! ArrayAccess(),
		Slice()   <! ArrayAccess(),
		String()  <! ArrayAccess(),
		
		Slice()   <! Array(),
		
		// Define class types.
		ClassType{"boolean"} <- s_global,
		ClassType{"boolean"} : ClassType(Boolean()),
		ClassType{"int"} <- s_global,
		ClassType{"int"} : ClassType(Int()),
		ClassType{"double"} <- s_global,
		ClassType{"double"} : ClassType(Double()),
		ClassType{"string"} <- s_global,
		ClassType{"string"} : ClassType(String()),
		ClassType{"array"} <- s_global,
		ClassType{"array"} : ClassType(Array()),
		ClassType{"slice"} <- s_global,
		ClassType{"slice"} : ClassType(Slice()),
		ClassType{"closure"} <- s_global,
		ClassType{"closure"} : ClassType(Closure()).
	
	// MethodScript program.
	[[ Empty() ^ (s_global) ]].
	
	[[ Program(prog) ^ (s_global) ]] :=
		
		// Disallow duplicate procedure declarations.
		distinct/name W(s_global)/Proc | error $[Duplicate procedure declaration: [NAME]] @NAMES,
		
		[[ prog ^ (s_global) ]].
	
	[[ Ms(statements) ^ (s_global) ]] :=
		
		// Create new scopes.
		new s_file, // File start scope.
		new s_file', // Second scope for terms that require an extra scope in the scope chain.
		new s_extra, // Extra scope that allows for looking up declarations in code branches.
		s_file' -P-> s_file, // First part of scope chain. Each statement will a scope pair to the previous.
		DSMap1T[[ statements ^ (s_file, s_file', s_extra, s_global) : _ ]].
	
	[[ Msa(cmds) ^ (s_global) ]] :=
		new s_file,
		Map1[[ cmds ^ (s_file, s_global) ]].
	
	// Variable references.
	[[ IVar(varName) ^ (s, s', s_extra, s_global) : t ]] :=
		IVar{varName} -> s, // varName is a reference in s.
		IVar{varName} |-> d | error $[Cannot find variable: [varName]],
		d : t.
	[[ Var(varName) ^ (s, s', s_extra, s_global) : t ]] :=
		Var{varName} -> s, // varName is a reference in s.
		Var{varName} |-> d | error $[Cannot find variable: [varName]],
		d : t.
	
	// IVariable parameters.
	// With 1 scope, the param is declared and resolved in the same scope.
	// With 2 scopes, the param is declared in the second scope and its value resolved in the first.
	// TODO - Check how many scopes IVar...Param terms need.
	[[ IVarParam(cType, varName) ^ (s, s', s_extra, s_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName@s} <- s,
		IVar{varName@s} : varType,
		varType == Any().
	[[ IVarAssignParam(cType, varName, valExp) ^ (s, s', s_extra, s_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName@s} <- s,
		IVar{varName@s} : varType,
		[[ valExp ^ (s, s', s_extra, s_global) : valType ]],
		varType == Any(). // TODO - Change to valType when every assign will have its own scope.
//		valType <? varType.
	[[ IVarScopeParam(cType, varName) ^ (s_parent, s_params, s_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName} <- s_params,
		IVar{varName} : varType,
		varType == Any().
	[[ IVarAssignScopeParam(cType, varName, valExp) ^ (s_parent, s_params, s_global) : varType ]] :=
		// TODO - Resolve cType (Some(str), None()) to a type and use this.
		IVar{varName} <- s_params,
		IVar{varName} : varType,
		[[ valExp ^ (s_parent, _, _, s_global) : valType ]],
		varType == Any().
//		valType <? varType.
	
	// Static values.
	[[ IntVal(_) ^ (s, s', s_extra, s_global) : Int() ]].
	[[ DoubleVal(_) ^ (s, s', s_extra, s_global) : Double() ]].
	[[ StringVal(_) ^ (s, s', s_extra, s_global) : String() ]].
	[[ SmartStringVal(_) ^ (s, s', s_extra, s_global) : String() ]].
	[[ ClassTypeVal(_) ^ (s, s', s_extra, s_global) : ClassType() ]].
	[[ True() ^ (s, s', s_extra, s_global) : Boolean() ]].
	[[ False() ^ (s, s', s_extra, s_global) : Boolean() ]].
	[[ Null() ^ (s, s', s_extra, s_global) : Null() ]].
	
	// Command declarations.
	[[ CmdDecl(cmdName, args, optArgs, body) ^ (s, s_global) ]] :=
		new s_cmd,
		new s',
		new s_extra,
		s' -P-> s_cmd,
		Map1[[ args ^ (s_cmd, s_global) ]],
		Map1[[ optArgs ^ (s_cmd, s_global) ]],
		[[ body ^ (s_cmd, s', s_extra, s_global) ]],
		distinct/name W(s_cmd)/Var | error $[Duplicate variable declaration: [NAME]] @NAMES.
	
	[[ CmdArgDecl(varName) ^ (s, s_global) ]] :=
		Var{varName} <- s,
		Var{varName} : String(). // All $variables are strings.
	
	[[ CmdOptArgDeclDefault(varName, defaultVal) ^ (s, s_global) ]] :=
		Var{varName} <- s,
		Var{varName} : String(), // All $variables are strings.
		[[ defaultVal ^ (s, _, _, s_global) : defaultValType ]],
		defaultValType <? String() | error $[Expected String, found [defaultValType]].
	
	[[ SingleLine(statement) ^ (s, s', s_extra, s_global) ]] :=
		[[ statement ^ (s, s', s_extra, s_global) : _ ]].
	[[ MultiLine(statements) ^ (s, s', s_extra, s_global) ]] :=
		DSMap1T[[ statements ^ (s, s', s_extra, s_global) : _ ]].
	
	// Unary and binary expressions.
	[[ UnExp(_, e) ^ (s, s', s_extra, s_global) : Any() ]] :=
		[[ e ^ (s, s', s_extra, s_global) : t1 ]].
	[[ BinExp(Add(), e1, e2) ^ (s, s', s_extra, s_global) : t ]] := // TODO - Determine how to implement + move Math section?
		[[ e1 ^ (s, s', s_extra, s_global) : t1 ]],
		[[ e2 ^ (s, s', s_extra, s_global) : t2 ]],
//		t1 <? Number(),
//		t2 <? Number(),
		t is binOpNumberType of (t1, t2). // TODO - Apply to all BinOps that take numbers like this.
	[[ BinExp(_, e1, e2) ^ (s, s', s_extra, s_global) : Any() ]] :=
		[[ e1 ^ (s, s', s_extra, s_global) : t1 ]],
		[[ e2 ^ (s, s', s_extra, s_global) : t2 ]].
	
	// Generic optional node argument.
	[[ None() ^ (s, s', s_extra, s_global) : _ ]] :=
		true.
	
	// Statement brackets.
	[[ Block(statements) ^ (s, s', s_extra, s_global) : _ ]] :=
		DSMap1T[[ statements ^ (s, s', s_extra, s_global) : _ ]].
	
	// Function calls.
	// TODO - Check against API to see whether a function exists?
	// TODO - Obtain type info from the API somehow?
	[[ FuncCall(funcName, argExps) ^ (s, s', s_extra, s_global) : Any() ]] :=
		Map1T[[ argExps ^ (s, s', s_extra, s_global) : argTypes ]].
	
	// ArrayHandling nodes.
	[[ ArrayPush(arrayExp, valExp) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ arrayExp ^ (s, s', s_extra, s_global) : arrayType ]],
		[[ valExp ^ (s, s', s_extra, s_global) : _ ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	[[ ArrayClone(arrayExp) ^ (s, s', s_extra, s_global) : Array() ]] :=
		[[ arrayExp ^ (s, s', s_extra, s_global) : arrayType ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	[[ ArrayGet(arrayExp, indExp) ^ (s, s', s_extra, s_global) : Any() ]] :=
		[[ arrayExp ^ (s, s', s_extra, s_global) : arrayType ]],
		[[ indExp ^ (s, s', s_extra, s_global) : _ ]],
		arrayType <? ArrayAccess() | error $[Type [arrayType] does not support array access].
	
	[[ SliceStatic(val1, val2) ^ (s, s', s_extra, s_global) : Slice() ]] :=
		true.
	
	[[ SliceDynamic(exp1, exp2) ^ (s, s', s_extra, s_global) : Slice() ]] :=
		[[ exp1 ^ (s, s', s_extra, s_global) : t1 ]],
		[[ exp2 ^ (s, s', s_extra, s_global) : t2 ]],
		t1 <? Int(),
		t2 <? Int().
	
	[[ ArraySet(arrayExp, indExp, valExp) ^ (s, s', s_extra, s_global) : valType ]] :=
		[[ arrayExp ^ (s, s', s_extra, s_global) : arrayType ]],
		[[ indExp ^ (s, s', s_extra, s_global) : t1 ]], // TODO - Only allow int or string here?
		[[ valExp ^ (s, s', s_extra, s_global) : valType ]],
		arrayType <? Array() | error $[Expected array, found [arrayType]].
	
	// BasicLogic nodes.
	// None (handled through UnOp and BinOp).
	
	// ControlFlow nodes.
	[[ IfElse(ifBlocks, None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ ifBlocks ^ (s, s', s_extra, s_global) : _ ]].
	[[ IfElse(ifBlocks, Some(elseCode)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ ifBlocks ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ elseCode ^ (s, s', s_extra, s_global) : _ ]].
	[[ IfElseIfBlock(cond, code) ^ (s, s', s_extra, s_global) : codeType ]] :=
		[[ cond ^ (s, s', s_extra, s_global) : condType ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : codeType ]],
		condType <? Boolean().
	
	[[ While(cond, code) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ cond ^ (s, s', s_extra, s_global) : condType ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		condType <? Boolean().
	
	[[ DoWhile(code, cond) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		[[ cond ^ (s, s', s_extra, s_global) : condType ]],
		condType <? Boolean().
	
	[[ For(assign, cond, exp, code, None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ assign ^ (s, s', s_extra, s_global) : _ ]],
		[[ cond ^ (s, s', s_extra, s_global) : condType ]],
		[[ exp ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		condType <? Boolean().
	[[ For(assign, cond, exp, code, elseCode) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ assign ^ (s, s', s_extra, s_global) : _ ]],
		[[ cond ^ (s, s', s_extra, s_global) : condType ]],
		[[ exp ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ elseCode ^ (s, s', s_extra, s_global) : _ ]],
		condType <? Boolean().
	
	[[ ForEach(key, val, arrayExp, code, None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ key ^ (s, s', s_extra, s_global) : _ ]],
		[[ val ^ (s, s', s_extra, s_global) : _ ]],
		[[ arrayExp ^ (s, s', s_extra, s_global) : arrayType ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		arrayType <? ArrayAccess().
	[[ ForEach(key, val, arrayExp, code, elseCode) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ key ^ (s, s', s_extra, s_global) : _ ]],
		[[ val ^ (s, s', s_extra, s_global) : _ ]],
		[[ arrayExp ^ (s, s', s_extra, s_global) : arrayType ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ elseCode ^ (s, s', s_extra, s_global) : _ ]],
		arrayType <? ArrayAccess().
	
	[[ Switch(exp, cases, defaultCode) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : _ ]],
		Map1[[ cases ^ (s, s', s_extra, s_global) ]],
		DSMap1T[[ defaultCode ^ (s, s', s_extra, s_global) : _ ]].
	[[ SwitchCase(vals, code) ^ (s, s', s_extra, s_global) ]] :=
		Map1T[[ vals ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]].
	
	[[ SwitchExp(exp, cases, defaultExp) ^ (s, s', s_extra, s_global) : returnType ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : _ ]],
		// TODO - Set returnType based on caseExpTypes and defaultType.
		Map1T[[ cases ^ (s, s', s_extra, s_global) : caseExpTypes ]],
		[[ defaultExp ^ (s, s', s_extra, s_global) : defaultType ]],
		returnType == Any().
	
	[[ SwitchExpCase(vals, exp) ^ (s, s', s_extra, s_global) : t ]] :=
		Map1T[[ vals ^ (s, s', s_extra, s_global) : _ ]],
		[[ exp ^ (s, s', s_extra, s_global) : t ]].
	[[ SwitchExpStmtsCase(vals, stmts) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ vals ^ (s, s', s_extra, s_global) : _ ]],
		// TODO - Ensure that the last stmt results in a throw, die, break, ...
		DSMap1T[[ stmts ^ (s, s', s_extra, s_global) : _ ]].
	
	[[ SwitchExpDefault(exp) ^ (s, s', s_extra, s_global) : t ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : t ]].
	[[ SwitchExpStmtsDefault(stmts) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Ensure that the last stmt results in a throw, die, break, ...
		DSMap1T[[ stmts ^ (s, s', s_extra, s_global) : _ ]].
	
	[[ Break(None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Only allow in loops.
		true.
	[[ Break(Some(numLoops)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Only allow in loops. How to deal with numLoops?
		[[ numLoops ^ (s, s', s_extra, s_global) : numLoopsType ]],
		numLoopsType <? Int().
	[[ Continue(None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Only allow in specific loops.
		true.
	[[ Continue(Some(numLoopsSkipped)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Only allow in specific loops.
		[[ numLoopsSkipped ^ (s, s', s_extra, s_global) : numLoopsSkippedType ]],
		numLoopsSkippedType <? Int().
	[[ Return(Some(exp)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Only allow in procedures and closures.
		[[ exp ^ (s, s', s_extra, s_global) : _ ]]. // TODO - Use this to determine procedure return types?
	[[ Return(None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Only allow in procedures and closures.
		true.
	[[ Die(Some(exp)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : expType ]],
		expType <? String().
	[[ Die(None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		true.
	
	[[ Ternary(cond, ifCase, elseCase) ^ (s, s', s_extra, s_global) : returnType ]] :=
		// TODO - Return hybrid type if possible?
		[[ cond ^ (s, s', s_extra, s_global) : condType ]],
		[[ ifCase ^ (s, s', s_extra, s_global) : t1 ]],
		[[ elseCase ^ (s, s', s_extra, s_global) : t2 ]],
		returnType == Any(),
		condType <? Boolean().
	[[ TernaryExpCase(exp) ^ (s, s', s_extra, s_global) : type ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : type ]].
	[[ TernaryStmtsCase(stmts) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Ensure that the last stmt results in a throw, die, break, ...
		DSMap1T[[ stmts ^ (s, s', s_extra, s_global) : _ ]].
	
	[[ ProcCall(procName, argExps) ^ (s, s', s_extra, s_global) : Any() ]] :=
		// TODO - Do argument length check. Warn about mismatching arg size?
		// The MS compiler simply ignores too many arguments and assigns null to undefined args.
		// TODO - Get return type from return statements.
		Proc{procName} -> s_global,
		Proc{procName} |-> d | error $[Cannot find procedure: [procName]],
		Map1T[[ argExps ^ (s, s', s_extra, s_global) : argTypes ]].
	
	[[ ProcCallDynamic(procNameExp, argExps) ^ (s, s', s_extra, s_global) : returnType ]] :=
		[[ procNameExp ^ (s, s', s_extra, s_global) : procNameType ]],
		Map1T[[ argExps ^ (s, s', s_extra, s_global) : argTypes ]],
		returnType == Any(),
		procNameType <? String().
	
	[[ ProcCallDynamicArray(procNameExp, argsArray) ^ (s, s', s_extra, s_global) : returnType ]] :=
		[[ procNameExp ^ (s, s', s_extra, s_global) : procNameType ]],
		[[ argsArray ^ (s, s', s_extra, s_global) : Array() ]],
		returnType == Any(),
		procNameType <? String().
	
	// DataHandling nodes.
	[[ ProcDecl(procName, params, code) ^ (s, s', s_extra, s_global) : Void() ]] :=
		
		// Store proc declaration in global scope.
		Proc{procName} <- s_global,
		// TODO - Store proc metadata (param types, return type).
		
		// Add s_params as child of the parent scope.
		new s_params,
		s_params ---> s,
		
		// Add s_proc as child of the params scope.
		new s_proc,
		s_proc ---> s_params,
		
		// Add parameters to params scope.
		Map1T[[ params ^ (s, s_params, s_global) : _ ]],
		
		// Resolve code in proc scope.
		new s_proc',
		s_proc' -P-> s_proc,
		new s_extra',
		DSMap1T[[ code ^ (s_proc, s_proc', s_extra', s_global) : _ ]].
	
	[[ Array(entries) ^ (s, s', s_extra, s_global) : Array()]] :=
		Map1T[[entries ^ (s, s', s_extra, s_global) : _ ]]. // TODO - Check for duplicate keys?
	[[ AssocArray(entries) ^ (s, s', s_extra, s_global) : Array() ]] :=
		Map1T[[entries ^ (s, s', s_extra, s_global) : _ ]]. // TODO - Check for duplicate keys?
	[[ ArrayLabelEntry(_, valExp) ^ (s, s', s_extra, s_global): _ ]] :=
		[[ valExp ^ (s, s', s_extra, s_global) : _ ]].
	
	// TODO - Check whether casts are possible on the given types?
	[[ BoolCast(exp) ^ (s, s', s_extra, s_global) : Boolean() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : t ]].
	[[ DoubleCast(exp) ^ (s, s', s_extra, s_global) : Double() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : t ]].
	[[ IntCast(exp) ^ (s, s', s_extra, s_global) : Int() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : t ]].
	[[ StringCast(exp) ^ (s, s', s_extra, s_global) : String() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : t ]].
	
	[[ Closure(params, code) ^ (s, s', s_extra, s_global) : Closure() ]] :=
		// TODO - Store metadata (param types, return type).
		
		// Add s_params as child of the parent scope.
		new s_params,
		s_params ---> s,
		
		// Add s_closure as child of the params scope.
		new s_closure,
		s_closure ---> s_params,
		
		// Add parameters to params scope.
		IVar{"@arguments"} <- s_params, // Automatically added.
		IVar{"@arguments"} : Array(),
		Map1T[[ params ^ (s, s_params, s_global) : _ ]],
		
		// Resolve code in closure scope.
		new s_closure',
		s_closure' -P-> s_closure,
		new s_extra',
		DSMap1T[[ code ^ (s_closure, s_closure', s_extra', s_global) : _ ]].
	
	[[ IClosure(params, code) ^ (s, s', s_extra, s_global) : Closure() ]] :=
		// TODO - Store metadata (param types, return type).
		
		// Create s_params.
		new s_params,
		
		// Add s_closure as child of the params scope.
		new s_closure,
		s_closure ---> s_params,
		
		// Add parameters to params scope.
		IVar{"@arguments"} <- s_params, // Automatically added.
		IVar{"@arguments"} : Array(),
		Map1T[[ params ^ (s, s_params, s_global) : _ ]],
		
		// Resolve code in closure scope.
		new s_closure',
		s_closure' -P-> s_closure,
		new s_extra',
		DSMap1T[[ code ^ (s_closure, s_closure', s_extra', s_global) : _ ]].
	
	[[ RClosure(params, code) ^ (s, s', s_extra, s_global) : Closure() ]] :=
		// TODO - Store metadata (param types, return type).
		
		// Create s_params.
		new s_params,
		
		// Add s_closure as child of the params scope.
		new s_closure,
		s_closure ---> s_params,
		
		// Add parameters to params scope.
		IVar{"@arguments"} <- s_params, // Automatically added.
		IVar{"@arguments"} : Array(),
		Map1T[[ params ^ (s, s_params, s_global) : _ ]],
		
		// Resolve code in closure scope.
		new s_closure',
		s_closure' -P-> s_closure,
		new s_extra',
		DSMap1T[[ code ^ (s_closure, s_closure', s_extra', s_global) : _ ]].
	
	[[ IVarAssign(Some(cType), varName, valExp) ^ (s, s', s_extra, s_global) : valType ]] :=
		
		// Resolve variable type.
		ClassType{cType} -> s_global,
		ClassType{cType} |-> cTypeDecl | error $[Unknown class type: [cType]] @cType,
		cTypeDecl : ClassType(declType),
		
		// Declare typed variable.
		TypedIVar{varName} <- s,
		TypedIVar{varName} : declType,
		
		// TODO - Not possible due to IVar{varName} already being defined in 's' in this IVarAssign code?
//		// Give a warning when an untyped variable declaration already exists for this varName.
//		new s_fvar,
//		new s_fvar2,
//		s_fvar -P-> s,
//		s_fvar -LP-> s_fvar2,
//		IVar{varName@s_fvar2} <- s_fvar2,
//		IVar{varName@s_fvar2} : FakeType(),
//		IVar{varName} -> s_fvar,
//		IVar{varName} |-> varDecl,
//		varDecl : varFakeType,
//		varFakeType == FakeType() | warning $[[varName] was already defined] @varName,
		
		// Disallow duplicate typed variable declarations.
		distinct/name W(s)/TypedIVar | error $[Duplicate variable declaration: [NAME]] @NAMES,
		
		// Resolve and type check assigned value.
		// TODO - Resolve valExp in a new scope that does not yet contain this variable declaration.
		[[ valExp ^ (s, s', s_extra, s_global) : valType ]],
		valType <? declType | error $[Type mismatch: Cannot convert from [valType] to [declType]] @valExp,
		
		// Declare variable assign.
		IVar{varName} <- s,
		IVar{varName} : valType.
	
	[[ IVarAssign(None(), varName, valExp) ^ (s, s', s_extra, s_global) : Any() ]] :=
		
		// Fake a typed variable declaration to set a default variable type.
		new s_fvar,
		new s_fvar2,
		s_fvar -P-> s,
		s_fvar -LP-> s_fvar2,
		TypedIVar{varName} <- s_fvar2,
		TypedIVar{varName} : Mixed(),
		
		// Get variable declaration type.
		TypedIVar{varName} -> s_fvar,
		TypedIVar{varName} |-> typedVarDecl,
		typedVarDecl : declType,
		
		// Resolve and type check the value expression.
		[[ valExp ^ (s, s', s_extra, s_global) : valType ]],
		valType <? declType | error $[Type mismatch: Cannot convert from [valType] to [declType]] @valExp,
		
		// Declare the variable assign.
		IVar{varName} <- s,
		IVar{varName} : valType.
	
	// EventBinding nodes.
	// TODO - Allow only in event context (within a Bind()).
	[[ Cancel(None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		true.
	[[ Cancel(exp) ^ (s, s', s_extra, s_global) : Void() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : Boolean() ]].
	
	[[ Consume() ^ (s, s', s_extra, s_global) : Void() ]] :=
		true.
	
	[[ Lock(exps) ^ (s, s', s_extra, s_global) : Void() ]] :=
		// TODO - Check types.
		Map1T[[ exps ^ (s, s', s_extra, s_global) : types ]].
	
	[[ IsCancelled() ^ (s, s', s_extra, s_global) : Boolean() ]] :=
		true.
	
	[[ IsConsumed() ^ (s, s', s_extra, s_global) : Boolean() ]] :=
		true.
	
	[[ IsLocked(exp) ^ (s, s', s_extra, s_global) : Boolean() ]] :=
		[[ exp ^ (s, s', s_extra, s_global) : String() ]].
	
	[[ Bind(name, prio, filter, eventVarName, params, code) ^ (s, s', s_extra, s_global) : String() ]] :=
		[[ name ^ (s, s', s_extra, s_global) : nameType ]],
		nameType <? String(),
		[[ prio ^ (s, s', s_extra, s_global) : prioType ]],
		prioType <? Array(),
		[[ filter ^ (s, s', s_extra, s_global) : filterType ]],
		filterType <? Array(),
		
		// Create s_params.
		new s_params,
		
		// Add s_bind as child of the params scope.
		new s_bind,
		s_bind ---> s_params,
		
		// Add event variable and parameters to params scope.
		IVar{eventVarName} <- s_params,
		IVar{eventVarName} : Array(),
		Map1T[[ params ^ (s, s_params, s_global) : _ ]],
		
		// Resolve code in bind scope.
		new s_bind',
		s_bind' -P-> s_bind,
		new s_extra',
		DSMap1T[[ code ^ (s_bind, s_bind', s_extra, s_global) : _ ]].
	
	[[ ModifyEvent(paramExp, valExp, Some(throwOnFailExp)) ^ (s, s', s_extra, s_global) : Boolean() ]] :=
		[[ paramExp ^ (s, s', s_extra, s_global) : paramType ]],
		paramType <? String(),
		[[ valExp ^ (s, s', s_extra, s_global) : _ ]],
		[[ throwOnFailExp ^ (s, s', s_extra, s_global) : throwOnFailType ]],
		throwOnFailType <? Boolean().
	[[ ModifyEvent(paramExp, valExp, None()) ^ (s, s', s_extra, s_global) : Boolean() ]] :=
		[[ paramExp ^ (s, s', s_extra, s_global) : paramType ]],
		paramType <? String(),
		[[ valExp ^ (s, s', s_extra, s_global) : _ ]].
	
	// Exceptions nodes.
	[[ TryLegacy(code, None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]].
	[[ TryLegacy(code, Some(catchBlock)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		[[ catchBlock ^ (s, s', s_extra, s_global) : _ ]].
	[[ CatchCodeLegacy(code) ^ (s, s', s_extra, s_global) : _ ]] :=
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]].
	[[ CatchBlockLegacy(param, code, None()) ^ (s, s', s_extra, s_global) : _ ]] :=
		[[ param ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]].
	[[ CatchBlockLegacy(param, code, Some(exceptions)) ^ (s, s', s_extra, s_global) : _ ]] :=
		[[ param ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		[[ exceptions ^ (s, s', s_extra, s_global) : exArrayType ]],
		exArraySize <? Array().
	
	[[ CTry(code, catchBlocks, None()) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		Map1T[[ catchBlocks ^ (s, s', s_extra, s_global) : _ ]].
	[[ CTry(code, catchBlocks, Some(finallyCode)) ^ (s, s', s_extra, s_global) : Void() ]] :=
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]],
		Map1T[[ catchBlocks ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ finallyCode ^ (s, s', s_extra, s_global) : _ ]].
	[[ CTryCatchBlock(param, code) ^ (s, s', s_extra, s_global) : _ ]] :=
		[[ param ^ (s, s', s_extra, s_global) : _ ]],
		DSMap1T[[ code ^ (s, s', s_extra, s_global) : _ ]].
	
	[[ GetStackTrace() ^ (s, s', s_extra, s_global) : Array() ]] :=
		true.
	
	// Math nodes.
	// None (handled through UnOp and BinOp).
	
	// StringHandling nodes.
	// None (handled through BinOp).

module MethodScript

imports
	Common

context-free start-symbols
	Start

sorts Start Statement Exp
context-free syntax
	Start.Empty = <>
//	Start.Msa = <> // TODO - Implement.
	Start.Ms = (Statement)*
//	Start.AutoIncludeMs = <> // TODO - Implement.
	
	// Statements. TODO - Implement all statements from the API.
	OptionalSemiColon.SemiColon = ";"
	OptionalSemiColon.None = ""
	// TODO - Move if's to Exp or only allow one Statement in both cases for Exp?
	Exp.If = <if(<Exp>) {
		<(Statement)*>
	}>
	Exp.IfElse = <if(<Exp>) {
		<(Statement)*>
	} else {
		<(Statement)*>
	}>
	Statement.While = <while(<Exp>) {
		<(Statement)*>
	}>
//	Statement.For = "for" "(" Statement ";" Statement ";" Statement ")" "{" Statement "}"
	Statement.ArrayPush = <<Exp>[] = <Exp><OptionalSemiColon>>
	/*
	 * TODO - Keep Exp and MultiExp or just make one Exp that accepts * expressions?
	 * This makes a block of expressions a single Statement. Is that desired?
	 */
	Statement.Exp = <<Exp><OptionalSemiColon
	>>
//	Statement.MultiExp = <<Exp><OptionalSemiColon>
//	(<Exp><OptionalSemiColon>
//	)+>
	
	// Expressions. TODO - Implement all expressions from the API.
	// Arithmetic operators.
	Exp.Plus = <<Exp> + <Exp>> {left}
	Exp.Minus = <<Exp> - <Exp>> {left, prefer}
	Exp.Times = <<Exp> * <Exp>> {left}
	Exp.Div = <<Exp> / <Exp>> {left}
	Exp.Mod = <<Exp> % <Exp>> {left}
	Exp.Pow = <<Exp> ** <Exp>> {left}
	Exp.Inc = <++<Exp>>
	Exp.PostInc = <<Exp>++>
	Exp.Dec = <--<Exp>>
	Exp.PostDec = <<Exp>-->
	Exp.Neg = <-<Exp>> {avoid}
	
	// String operators.
	Exp.Concat = <<Exp> . <Exp>> {left} // TODO - Check associativity.
	
	// Logical operators.
	Exp.And = <<Exp> && <Exp>> {left}
	Exp.Or = <<Exp> || <Exp>> {left}
	Exp.Dand = <<Exp> &&& <Exp>> {left}
	Exp.Dor = <<Exp> ||| <Exp>> {left}
	Exp.Not = <!<Exp>>
	
	// Comparison operators.
	Exp.Equals     = <<Exp> ==  <Exp>> {left}
	Exp.NotEquals  = <<Exp> != <Exp>>  {left}
	Exp.Sequals    = <<Exp> === <Exp>> {left}
	Exp.NotSequals = <<Exp> !== <Exp>> {left}
	Exp.Lt         = <<Exp> \< <Exp>>  {left}
	Exp.Lte        = <<Exp> \<= <Exp>> {left}
	Exp.Gt         = <<Exp> \> <Exp>>  {left}
	Exp.Gte        = <<Exp> \>= <Exp>> {left}
	
	// Variables.
	Exp.IVar = IVAR
	Exp.Var = VAR
	
	// Static values.
	Exp.Int = INT
	Exp.Float = FLOAT
	Exp.String = STRING
	Exp.SmartString = SMART-STRING
	Exp.True = "true"
	Exp.False = "false"
	Exp.Null = "null"
	
	Exp.IVarAssign = <<IVAR> = <Exp>>
	Exp.ArraySet = <<Exp>[<Exp>] = <Exp>> {left} // TODO - Check associativity.
	Exp.ArrayGet = <<Exp>[<Exp>]> {left} // TODO - Check associativity.
	Exp.ArrayClone = <<Exp>[]> // Maps to array_deep_clone(array).
	Exp.ArraySlice = <<Exp>[<INT>..<INT>]>
	Exp.Array = <array(<{ArrayEntry ","}*>)>
	Exp.AssocArray = <associative_array(<{ArrayEntry ","}*>)>
	ArrayEntry.Entry = <<LABEL>: <Exp>>
	ArrayEntry.Val = Exp
	// TODO - Give Statement function arguments a different label?
	Exp.ProcCall = <<PROC-ID>(<{Exp ","}*>)> {left} // TODO - Check associativity.
	Exp.FuncCall = <<FUNC-ID>(<{(Statement)+ ","}*>)> {left} // TODO - Check associativity.
	Exp = <(<Exp>)> {bracket}

context-free priorities
	// Binary operator priorities (tested): {**} > {*, /, %} > {+, -, .} > {>, <, >=, <=} > {==, !=, ===, !==}
	// > {&&&} > {|||} > {&&} > {||} > {assign, array_set}.
	// Unary operator priorities (tested): {array_clone, array_get, array_slice} > {neg} > {postinc, postdec}
	// > {inc, dec} > {not}.
	Exp.Pow > {left: Exp.Times Exp.Div Exp.Mod} > {left: Exp.Plus Exp.Minus Exp.Concat}
			> {Exp.Gt Exp.Lt Exp.Gte Exp.Lte} > {Exp.Equals Exp.NotEquals Exp.Sequals Exp.NotSequals}
			> Exp.Dand > Exp.Dor > Exp.And > Exp.Or > {Exp.IVarAssign Exp.ArraySet},
	{Exp.ArrayClone Exp.ArrayGet Exp.ArraySlice} > Exp.Neg > {Exp.PostInc Exp.PostDec} > {Exp.Inc Exp.Dec} > Exp.Not
	
//	Exp+ = Exp+ Exp <1> .> Exp.Neg,
//	Exp+ = Exp <0> .> Exp.Neg
//	Exp.Minus <0> .> Exp.Neg,

//	Exp = Exp "-" Exp <0> .> Exp.Neg,
//	Exp = Exp "-" Exp <1> .> Exp.Neg,
//	Exp = Exp "-" Exp <2> .> Exp.Neg,
//	Exp = Exp "-" Exp <3> .> Exp.Neg,
//	Exp = Exp "-" Exp <4> .> Exp.Neg,
//	Exp = Exp "-" Exp <5> .> Exp.Neg

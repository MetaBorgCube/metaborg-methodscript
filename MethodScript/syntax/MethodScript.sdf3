module MethodScript

imports
	Common

context-free start-symbols
	Start

context-free syntax
	Start.Empty = <>
//	Start.Msa = <> // TODO - Implement.
	Start.Ms = Statement+
//	Start.AutoIncludeMs = <> // TODO - Implement.
	
	/*
	 * Statement: Single coherent code that does not result in a value. Cannot be used as Exp.
	 * SExp: Statement that resolves to some value. Can be used as Statement and as Exp.
	 * Exp: Expression that resolves to some value. Cannot be used as Statement.
	 */
	 Statement.SExp = <<SExp><SemiColon?>
	 >
	 Exp.SExp = SExp
	
	// Statements. TODO - Implement all statements from the API.
	// Branching statements.
	Statement.If = <if(<Exp>) {
		<Statement*>
	}>
	
	Statement.IfLegacy = <if(<Exp>,
		<Statement+>
	)<SemiColon?>>
	
	Statement.IfElse = <if(<Exp>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	Statement.IfElseLegacy = <if(<Exp>,
		<Statement+>
	,
		<Statement+>
	)<SemiColon?>>
	
	Statement.While = <while(<Exp>) {
		<Statement*>
	}>
	
	Statement.WhileLegacy = <while(<Exp>,
		<Statement+>
	)<SemiColon?>>
	
	Statement.DoWhile = <do {
		<Statement*>
	while(<Exp>)<SemiColon?>>
	
	Statement.DoWhileLegacy = <dowhile(
		<Statement+>
	, <Exp>)<SemiColon?>>
	
	// TODO - Rename for and foreach nodes? Add optional else case to them or keep them separated?
	// TODO - Decide whether to support the actual forelse() and foreachelse() functions as well.
	Statement.For1 = <for(<IVAR> = <Exp>; <Exp>; <Exp>) {
		<Statement*>
	}>
	
	Statement.For2 = <for(<IVAR> = <Exp>, <Exp>, <Exp>) {
		<Statement*>
	}>
	
	Statement.ForLegacy = <for(<IVAR> = <Exp>, <Exp>, <Exp>,
		<Statement+>
	)<SemiColon?>>
	
	Statement.ForElse1 = <for(<IVAR> = <Exp>; <Exp>; <Exp>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	Statement.ForElse2 = <for(<IVAR> = <Exp>, <Exp>, <Exp>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	Statement.ForElseLegacy = <forelse(<IVAR> = <Exp>, <Exp>, <Exp>,
		<Statement+>
	,
		<Statement+>
	)<SemiColon?>>
	
	// "foreach(@value in @array) {code}".
	Statement.ForEach1 = <foreach(<IVAR> in <Exp>) {
		<Statement*>
	}>
	
	// "foreach(@array as @value) {code}".
	Statement.ForEach2 = <foreach(<Exp> as <IVAR>) {
		<Statement*>
	}>
	
	// "foreach(@array, @value) {code}".
	Statement.ForEach3 = <foreach(<Exp>, <IVAR>) {
		<Statement*>
	}>
	
	// "foreach(@key: @value in @array) {code}".
	Statement.ForEach4 = <foreach(<IVAR>: <IVAR> in <Exp>) {
		<Statement*>
	}>
	
	// "foreach(@array, @key, @value) {code}".
	Statement.ForEach5 = <foreach(<Exp>, <IVAR>, <IVAR>) {
		<Statement*>
	}>
	
	Statement.ForEachLegacy1 = <foreach(<Exp>, <IVAR>,
		<Statement+>
	)<SemiColon?>>
	
	Statement.ForEachLegacy2 = <foreach(<Exp>, <IVAR>, <IVAR>,
		<Statement+>
	)<SemiColon?>>
	
	// "foreach(@value in @array) {code} else {code}".
	Statement.ForEachElse1 = <foreach(<IVAR> in <Exp>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	// "foreach(@array as @value) {code} else {code}".
	Statement.ForEachElse2 = <foreach(<Exp> as <IVAR>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	// "foreach(@array, @value) {code} else {code}".
	Statement.ForEachElse3 = <foreach(<Exp>, <IVAR>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	// "foreach(@key: @value in @array) {code} else {code}".
	Statement.ForEachElse4 = <foreach(<IVAR>: <IVAR> in <Exp>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	// "foreach(@array, @key, @value) {code} else {code}".
	Statement.ForEachElse5 = <foreach(<Exp>, <IVAR>, <IVAR>) {
		<Statement*>
	} else {
		<Statement*>
	}>
	
	Statement.ForEachElseLegacy1 = <foreachelse(<Exp>, <IVAR>,
		<Statement+>
	,
		<Statement+>
	)<SemiColon?>>
	
	Statement.ForEachElseLegacy2 = <foreachelse(<Exp>, <IVAR>, <IVAR>,
		<Statement+>
	,
		<Statement+>
	)<SemiColon?>>
	
	// TODO - Implement switch(). Statement when it contains Statements, Exp when it contains a single Exp in each case.
	// TODO - Determine what to do when some cases have a single exp and some return or throw an exception or so.
	// TODO - Fix ambiguity in Exp/Statement code (both can lead to SExp).
	SExp.SwitchCaseLegacy = <switch(<Exp><SwitchCaseLegacy*><SwitchCaseDefaultLegacy?>
	)>
	SwitchCaseLegacy.ExpCase = <,
		<Exp>,
			<Exp+>>
	SwitchCaseLegacy.StatementCase = <,
		<Exp>,
			<Statement+>>
	SwitchCaseDefaultLegacy.ExpDefault = <,
		<Exp>,
			<Exp>>
	SwitchCaseDefaultLegacy.StatementDefault = <,
		<Exp>,
			<Statement+>>
	
	Statement.Break = <break(<Exp?>)> // break([numLoops]).
	Statement.Continue = <continue(<Exp?>)> // continue([numLoopsSkipped]).
	Statement.Return = <return(<Exp?>)> // return([value]).
	Statement.Die = <die(<Exp?>)> // die([message]).
	
	// Other statements.
	Statement.ArrayPush = <<Exp>[] = <Exp><SemiColon?>>
	Statement.ProcDecl = <proc <PROC-ID>(<{IVAR ","}*>) {
		<Statement*>
	}>
	Statement.ProcDecl2 = <proc(<Exp><ProcArgVar*>) {
		<Statement*>
	}>
	Statement.ProcDeclLegacy = <proc(<Exp><ProcArgVar*>,
		<Statement+>
	)<SemiColon?>>
	ProcArgVar.ProcArgVar = <, <IVAR>>
	
	// "bind(eventName, options, prefilter, eventObj, [customParams], code)".
	// customParams may be IVARs, but also IVAR assignments (@var = ...). TODO - Implement more strictly.
	SExp.Bind = <bind(<Exp>, <Exp>, <Exp>, <IVAR><BindParam*>) {
		<Statement*>
	}>
	SExp.BindLegacy = <bind(<Exp>, <Exp>, <Exp>, <IVAR><BindParam*>,
		<Statement*>
	)>
	BindParam.Param = <, <Exp>>
	
	Statement.Block = <(
		<Statement*>
	)>
	
	SemiColon.SemiColon = ";"
	
	// Expressions. TODO - Implement all expressions from the API.
	// Arithmetic operators.
	Exp.Plus = <<Exp> + <Exp>> {left}
	Exp.Minus = <<Exp> - <Exp>> {left}
	Exp.Times = <<Exp> * <Exp>> {left}
	Exp.Div = <<Exp> / <Exp>> {left}
	Exp.Mod = <<Exp> % <Exp>> {left}
	Exp.Pow = <<Exp> ** <Exp>> {left}
	Exp.Neg = <-<Exp>>
	
	SExp.Inc = <++<IVAR>>
	SExp.PostInc = <<IVAR>++>
	SExp.Dec = <--<IVAR>>
	SExp.PostDec = <<IVAR>-->
	
	// String operators.
	Exp.Concat = <<Exp> . <Exp>> {left} // TODO - Check associativity.
	
	// Logical operators.
	Exp.And = <<Exp> && <Exp>> {left}
	Exp.Or = <<Exp> || <Exp>> {left}
	Exp.Dand = <<Exp> &&& <Exp>> {left}
	Exp.Dor = <<Exp> ||| <Exp>> {left}
	Exp.Not = <!<Exp>>
	
	// Comparison operators.
	Exp.Equals     = <<Exp> ==  <Exp>> {left} // TODO - Keep left of set to non-assoc (accept nested equals or not)?
	Exp.NotEquals  = <<Exp> != <Exp>>  {left} // TODO - Keep left of set to non-assoc (accept nested equals or not)?
	Exp.Sequals    = <<Exp> === <Exp>> {left} // TODO - Keep left of set to non-assoc (accept nested equals or not)?
	Exp.NotSequals = <<Exp> !== <Exp>> {left} // TODO - Keep left of set to non-assoc (accept nested equals or not)?
	Exp.Lt         = <<Exp> \< <Exp>>  {non-assoc}
	Exp.Lte        = <<Exp> \<= <Exp>> {non-assoc}
	Exp.Gt         = <<Exp> \> <Exp>>  {non-assoc}
	Exp.Gte        = <<Exp> \>= <Exp>> {non-assoc}
	
	// Variables.
	Exp.IVar = IVAR
	Exp.Var = VAR
	
	// Static values.
	Exp.Int = INT
	Exp.Float = FLOAT
	Exp.String = STRING
	Exp.SmartString = SMART-STRING
	Exp.True = "true"
	Exp.False = "false"
	Exp.Null = "null"
	
	// Branching operators.
	Exp.Ternary = <if(<Exp>) {<Exp>} else {<Exp>}> // "@val = if(cond) {exp1} else {exp2}".
	Exp.TernaryLegacy = <if(<Exp>, <Exp>, <Exp>)> // "@val = if(cond, exp1, exp2}".
	
	// Casts.
	Exp.BoolCast = <boolean(<Exp>)>
	Exp.DoubleCast = <double(<Exp>)>
	Exp.IntCast = <integer(<Exp>)>
	Exp.StringCast = <string(<Exp>)>
//	Exp.SmartStringCast = <smart_string(<Exp>)> // TODO - Only accepts hard-coded string as arg, so this isn't a cast?
	// TODO - Implement all casts.
	
	SExp.IVarAssign = <<IVAR> = <Exp>>
	SExp.ArraySet = <<Exp>[<Exp>] = <Exp>> // TODO - Check associativity.
	Exp.ArrayGet = <<Exp>[<Exp>]> // TODO - Check associativity.
	Exp.ArrayClone = <<Exp>[]> // Maps to array_deep_clone(array).
	// TODO - Allow INT and <"-"<INT>> in Slice.
	Exp.ArraySlice = <<Exp>[<INT>..<INT>]> // TODO - Move Exp.Slice out of there and make this ArrayGet(..., Slice()).
	Exp.Array = <array(<{ArrayEntry ","}*>)>
	Exp.AssocArray = <associative_array(<{ArrayEntry ","}*>)>
	ArrayEntry.Entry = <<LABEL>: <Exp>>
	ArrayEntry.Val = Exp
	
	// Procedure and function calls. Functions that accept code blocks as an argument should be defined separately.
	SExp.ProcCall = <<PROC-ID>(<{Exp ","}*>)>
	SExp.FuncCall = <<FUNC-ID>(<{Exp ","}*>)>
	
	// Closures.
	// TODO - Closures accept IVARs as first arguments, but also assigns. Make a choice in what to accept here.
	Exp.Closure = <closure(<{Exp ","}*>) {
		<Statement*>
	}>
	Exp.ClosureLegacy = <closure(<ClosureVar*>
		<Statement+>
	)<SemiColon?>>
	Exp.IClosure = <iclosure(<{Exp ","}*>) {
		<Statement*>
	}>
	Exp.IClosureLegacy = <iclosure(<ClosureVar*>
		<Statement+>
	)<SemiColon?>>
	Exp.RClosure = <rclosure(<{Exp ","}*>) {
		<Statement*>
	}>
	Exp.RClosureLegacy = <rclosure(<ClosureVar*>
		<Statement+>
	)<SemiColon?>>
	ClosureVar.ClosureVar = <<Exp>, > // TODO - Fix trailing whitespace if it matters for pretty-printing.
	
	// Brackets. These are allowed around statements and expressions.
	// TODO - Allow brackets around multiple statements. Could define a Statement.Block for this.
	Exp = <(<Exp>)> {bracket}
//	Statement = <(<Statement>)> {bracket} // TODO - Remove if properly handled by Statement.Block.

context-free priorities
	// Operator priorities (tested): {array_clone, array_get, array_slice} > {neg, not} > {**} > {*, /, %} > {+, -, .}
	// > {>, <, >=, <=} > {==, !=, ===, !==} > {&&&} > {|||} > {&&} > {||} > {assign, array_set}.
	// Unary operator priorities (tested): {neg} > {postinc, postdec} > {inc, dec} > {not}.
	{Exp.ArrayClone Exp.ArrayGet Exp.ArraySlice}
			> {Exp.Neg Exp.Not}
			> Exp.Pow
			> {left: Exp.Times Exp.Div Exp.Mod}
			> {left: Exp.Plus Exp.Minus Exp.Concat}
			> {non-assoc: Exp.Gt Exp.Lt Exp.Gte Exp.Lte}
			> {Exp.Equals Exp.NotEquals Exp.Sequals Exp.NotSequals}
			> Exp.Dand > Exp.Dor > Exp.And > Exp.Or
			> {SExp.IVarAssign SExp.ArraySet}
